\documentclass[12pt]{article} \usepackage{amsthm,amsfonts,amssymb} \newtheorem{theorem}{Theorem} \begin{document} \begin{theorem} $ <nat:464> \cdot <var:D> + <nat:305> + <nat:402> \cdot <var:W> + <var:a> \cdot <nat:46> + <var:K> \cdot <nat:60> + <var:k> \cdot <nat:480> $ is guaranteed to be odd . \end{theorem} \begin{proof} The positive integer $ <nat:402> $ is clearly an even element of $ \mathbb{N} $ . For this reason , $ <nat:402> \cdot <var:W> $ is even too . Recall that the natural number $ <nat:60> $ is known as an even number in $ \mathbb{Z}^+ $ . Therefore , the product $ <var:K> \cdot <nat:60> $ is even additionally . Further , the product $ <nat:464> \cdot <var:D> $ is clearly even . This is true from the fact the product between an even integer and some natural number must be even . This claim holds because the natural number $ <nat:464> $ is clearly an even number in $ \mathbb{Z}^+ $ . Likewise , the number $ <nat:480> $ is clearly an even positive integer . Accordingly , $ <var:k> \cdot <nat:480> $ will be even as well . What's more , take note that the term $ <nat:46> \cdot <var:a> $ is known to be an even element of $ \mathbb{Z}^+ $ . This is true since the multiplication of an even whole number and a positive integer is guaranteed to be by definition an even number in $ \mathbb{Z}^+ $ plus the leading term $ <nat:46> $ is known to be an even natural number . We know $ <nat:305> $ is an odd number in $ \mathbb{Z}^+ $ . It can be proven that $ <var:D> <nat:464> + <var:a> <nat:46> + <var:K> <nat:60> + <var:k> <nat:480> + <nat:305> + <var:W> <nat:402> $ is odd . \end{proof} \end{document} 
~
Require Import Arith . Theorem <genP:1> : forall <var:D> <var:W> <var:a> <var:K> <var:k> : nat , Nat . odd ( <nat:464> * <var:D> + <nat:402> * <var:W> + <nat:46> * <var:a> + <nat:60> * <var:K> + <nat:480> * <var:k> + <nat:305> ) = true . Proof . intros . assert ( <genH> : Nat . even <nat:402> = true ) . { auto . } assert ( <genH> : Nat . even ( <nat:402> * <var:W> ) = true ) . { rewrite Nat . even_mul . rewrite <genH> . auto . } assert ( <genH> : Nat . even <nat:60> = true ) . { auto . } assert ( <genH> : Nat . even ( <nat:60> * <var:K> ) = true ) . { rewrite Nat . even_mul . rewrite <genH> . auto . } assert ( <genH> : Nat . even <nat:464> = true ) . { auto . } assert ( <genH> : Nat . even ( <nat:464> * <var:D> ) = true ) . { rewrite Nat . even_mul . rewrite <genH> . auto . } assert ( <genH> : Nat . even <nat:480> = true ) . { auto . } assert ( <genH> : Nat . even ( <nat:480> * <var:k> ) = true ) . { rewrite Nat . even_mul . rewrite <genH> . auto . } assert ( <genH> : Nat . even <nat:46> = true ) . { auto . } assert ( <genH> : Nat . even ( <nat:46> * <var:a> ) = true ) . { rewrite Nat . even_mul . rewrite <genH> . auto . } assert ( <genH> : Nat . odd <nat:305> = true ) . { auto . } rewrite Nat . odd_add . rewrite <- Nat . negb_even . repeat rewrite Nat . even_add . rewrite <genH> . rewrite <genH> . rewrite <genH> . rewrite <genH> . rewrite <genH> . rewrite <genH> . auto . Qed . 